Set Implicit Arguments.
Set Asymmetric Patterns.

Require Import List.
Require Import Omega.

(* import `measure` to make sure that `merge_or`'s arguments are decreasing in size. *)
Require Coq.Program.Wf.

Require Import comparable.
Require Import compare_regex.
Require Import dup.
Require Import derive.
Require Import nullable.
Require Import regex.
Require Import size.
Require Import sort.

(*
Here we define smart_or and smart_or'.
These are smart constructors which apply simplification rules during construction to normalize the expression.
This is useful for minimizing the state space.
These smart constructors assume that the regular expressions provided as input has also been smart constructed.

 - smart_or: applies the minimal simplification rules: idempotency, associativity and commutativity.
 - smart_or': applies more simplification rules.
*)

(* TODO: Help Wanted
Define a property `is_smart_or` that expresses the type the `smart_or` function returns.
`is_smart_or {X: Set} {tc: comparable X} (r: regex X) : Prop`
It should express that the tree is sorted and duplicates have been removed.
*)

(* TODO: Help Wanted
Use the previous defined property `is_smart_or` to prove:
```
smart_or_is_correct: forall {X: Set} {tc: comparable X} 
  (r s: regex X) (is_smart_or r) (is_smart_or s),
  is_smart_or (smart_or r s)
```

It is important that `smart_or` is fixed to call `merge_or` first.
*)

(* TODO: Help Wanted
Call merge_or, instead of this naive smart_or function, that doesn't reorder recursively.
It will break proofs in other files, so this todo is more about fixing those proofs.
*)
Definition smart_or {X: Set} {tc: comparable X} (r s: regex X) : regex X :=
  match compare_regex r s with
  | Eq => s
  | Lt => or r s
  | Gt => or s r
  end.

(*
merge_or merges two regexes.
It applies a merge sort on the root ors, while removing duplicates.
It can do this because of the following properties:
  idempotency: r + r = r
  commutativity: r + s = s + r
  associativity: (r + s) + t = r + (s + t)
It does this to normalize the regular expression.
It assumes the two regexes that is provided as input is already sorted with duplicates removed.

Program Fixpoint is used to we can set `measure` as the fixpoint's descreasing argument.
For more details, see:
https://stackoverflow.com/questions/47816742/decreasing-argument-and-what-is-a-program-fixpoint
https://coq.inria.fr/refman/addendum/program.html

We use Section here to make sure we solve the obligations generated by Program,
before moving onto proving or defining something else.
*)
Section merge_or.

Set Transparent Obligations.

Program Fixpoint merge_or {X: Set} {tc: comparable X} (r s: regex X) {measure ((size r)+(size s))} : regex X :=
  match r with
  | or r_1 r_next =>
    match s with
    | or s_1 s_next =>
      match compare r_1 s_1 with
      | Lt => or r_1 (merge_or r_next s)
      | Eq => or r_1 (merge_or r_next s_next)
      | Gt => or s_1 (merge_or r s_next)
      end
    | _ =>
      match compare r_1 s with
      | Lt => or r_1 (merge_or r_next s)
      | Eq => r
      | Gt => or s r
      end
    end
  | _ =>
    match s with
    | or s_1 s_next =>
      match compare r s_1 with
      | Lt => or r s
      | Eq => s
      | Gt => or s_1 (merge_or r s_next)
      end
    | _ =>
      match compare r s with
      | Lt => or r s
      | Eq => s
      | Gt => or s r
      end
    end
  end.

(*
Program has no generated obligations for several branches that need to be proved.
They all look quite similar, for example:
`size r_next + size (or s_1 s_next) < size (or r_1 r_next) + size (or s_1 s_next)`
which when simplified, look like:
`size r_next + S (size s_1 + size s_next) < S (size r_1 + size r_next + S (size s_1 + size s_next))`
which is the same as:
`x + S (y + z) < S (w + x + S (y + z))`
This is true, but probably a large proof to do manually,
so we use tactic omega to prove it for us.
*)

Next Obligation.
simpl.
omega.
Qed.

Next Obligation.
simpl.
omega.
Qed.

Next Obligation.
simpl.
omega.
Qed.

Next Obligation.
simpl.
omega.
Qed.

Next Obligation.
simpl.
omega.
Qed.

End merge_or.

(* TODO: Help Wanted
Is there a way to define merge_or without using `Program` and/or `measure`?
Remember you are not allowed to use the rule:
`r + nothing = r`
as we do below in an alternative `smart_or`'
If there is a way define the new version of `merge_or'`
Else add a comment to explain why these more powerful tools are needed.
*)

(* to_list_or is a helper function for smart_or'
It turns a regex into a list of ors, for example:
```
to_list_or (or nothing empty) = [nothing, empty]
to_list_or (or nothing (or empty (char x))) = [nothing, empty, char x]
```
It only turns the top level into ors and doesn't recurse past other operators:
```
to_list_or (or (and (or a b) c) (or empty (char x))) = [and (or a b) c, empty, char x]
```
It also doesn't recurse down the left side into or operators, 
since it expects the previous construction into a tree was done in a way that satifies this property:
```
to_list_or (or (or empty nothing) (or empty (or nothing empty))) = [or empty nothing, empty, nothing, empty]
```
*)
Fixpoint to_list_or {X: Set} {tc: comparable X} (r: regex X) : list (regex X) :=
  match r with
  | or s t => s :: to_list_or t
  | _ => r :: nil
  end.

(* TODO: Help Wanted
Define the property described in the comments of to_list_or
Also find the appropriate/official name for this property.
I am pretty sure this already has a name, but I can't find or remember it.
*)

(* to_tree_or creates a regex from a list of regexes by combining them with an `or` operator.
   At the end of the list a `nothing` expression is insert as this is the identity expression for `or.`
*)
Fixpoint to_tree_or {X: Set} (xs: list (regex X)) : regex X :=
  match xs with
  | nil => nothing _
  | (x'::xs') => or x' (to_tree_or xs')
  end.

(* to_list_or__to_tree_or__is_id shows that:
`to_tree_or . to_list_or = id`
*)
Theorem to_list_or__to_tree_or__is_id: forall {X: Set} {tc: comparable X} (r: regex X) (xs: list X),
  matches r xs = matches (to_tree_or (to_list_or r)) xs.
Proof.
induction r; try (simpl; intros xs; rewrite or_id; reflexivity).
- simpl.
  intros xs.
  rewrite or_is_logical_or.
  rewrite or_is_logical_or.
  rewrite IHr2.
  reflexivity.
Qed.

(*
  smart_or' applies all the following rules
  r + r = r
  r + s = s + r
  (r + s) + t = r + (s + t)
  r + nothing = r
*)
Definition smart_or' {X: Set} {tc: comparable X} (r s: regex X) : regex X :=
  to_tree_or (remove_duplicates_from_sorted (fold_left insert_sort (to_list_or r) (to_list_or s))).

